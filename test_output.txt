<html>
    <head>
        <meta description="Stock hue cycle."/>
        <meta publisher="WhirlwindFX" />
        <meta property="speed" label="Cycle Speed" type="number" min="1" max="10" default="2">
    </head>
        
    <body style="margin: 0; padding: 0;">
        <canvas id="exCanvas" width="1280" height="740" style="width: 100%; height: 100%"></canvas>
    </body>
        
    <script> 
// Seconds since epoch
const getTime = () => Math.round(Date.now())
const updatePixels = (pixelIds, rgb, newPixelColors) => {
    pixelIds.forEach(pixelId => newPixelColors[pixelId] = rgb)
}
const newFrame = (pixelIds, rgb, defaultRgb) => {
    let newPixelColors = []
    for(let i = 0; i < pixelAmount; i++) {
        newPixelColors[i] = defaultRgb
    }

    pixelIds.forEach(pixelId => newPixelColors[pixelId] = rgb)
    return newPixelColors
}

const pixelSize = [12, 740]
const pixelAmount = 8
const pixelsPositions = [
    [initial, 0],
    [initial + pixelSize[0] * 1, 0],
    [initial + pixelSize[0] * 2, 0],
    [initial + pixelSize[0] * 3, 0],
    [initial + pixelSize[0] * 4, 0],
    [initial + pixelSize[0] * 5, 0],
    [initial + pixelSize[0] * 6, 0],
    [initial + pixelSize[0] * 7, 0],
]

// Engine, no need to understand it
const drawPixels = (ctx, pixelsColors) => {
    for(let i = 0; i < pixelAmount; i++) {
        const color = pixelsColors[i]
        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})` 

        const pixelPosition = pixelsPositions[i]
        ctx.fillRect(pixelPosition[0], pixelPosition[1], pixelSize[0], pixelSize[1])
    }
}

// Get the canvas element from the DOM
let c = document.getElementById('exCanvas')
let ctx = c.getContext('2d')  
const sumVectors = ([c11, c12], [c21,c22]) => [c11 + c21, c12 + c22]
const scaleVector = (scalar, [c1, c2]) => [scalar * c1, scalar * c2]
const substractVectors = ([c11, c12], [c21,c22]) => [c11 - c21, c12 - c22]

const rotate = (angle, baseVector, tangentVector) => {
  let cosBase = scaleVector(Math.cos(angle), baseVector)
  let sinTang = scaleVector(Math.sin(angle), tangentVector)
  let positiveTangent = sumVectors(cosBase, sinTang)
  let negativeTangent = substractVectors(cosBase, sinTang)

  return [positiveTangent, negativeTangent]
}
const getFanPoints = () => {
  const a = 2 * Math.PI / pixelAmount;
  const r = 20;
  const fanPoints = []

  for (var i = 0; i < pixelAmount; i++) {
    fanPoints[i] = [r * Math.cos(a * i + a * 1.5), r * Math.sin(a * i + a * 1.5)];
  }
  return fanPoints
}
let fanPoints = getFanPoints()

const drawTriangles = (ctx, x, y, pixelsColors) => {
      for(let i = 0; i < pixelAmount; i++) {
        ctx.beginPath()
        ctx.moveTo(x, y)
        ctx.lineTo(x + fanPoints[i][0], y + fanPoints[i][1])
        ctx.lineTo(x + fanPoints[(i + 1) % pixelAmount][0], y + fanPoints[(i + 1) % pixelAmount][1])
        ctx.fillStyle = `rgb(${pixelsColors[i][0]}, ${pixelsColors[i][1]}, ${pixelsColors[i][2]})` 
        ctx.fill()
        ctx.closePath()
      }
}

const interpolatePixels = (p1, p2, interpolationWeight) => {
    let interpolatedPixel = []
    for(let i = 0; i < 3; i++) {
        interpolatedPixel[i] = p1[i] * (1 - interpolationWeight) + p2[i] * interpolationWeight
    }
    return interpolatedPixel
}

const interpolateFrames = (oldFrame, nextFrame, interpolationWeight, interpolationStart) => {
    if(interpolationWeight >= interpolationStart) {
      let realInterpolationWeight = (interpolationWeight - interpolationStart) / (1 - interpolationStart) 
      let interpolatedFrames = []
      for(let i = 0; i < pixelAmount; i++) {
          interpolatedFrames[i] = interpolatePixels(oldFrame[i], nextFrame[i], realInterpolationWeight)
      }
      return interpolatedFrames
    } else {
      return oldFrame
    }
}

function initEngine(baseFrame, nextFrameThreshold, interpolationStart, calculateNewAnimationState) {
  let animationState = {
      oldFrame: [...baseFrame],
      nextFrame: [...baseFrame],
      lastFrameTime: getTime(),
      timeSinceFrame: 0,
      extraFields: {},
  }

  const update = () => {
      let currentTime = getTime()
      timeSinceFrame = currentTime - animationState.lastFrameTime
      if(timeSinceFrame >= nextFrameThreshold) {
          animationState.lastFrameTime += nextFrameThreshold

          let oldestFrame = animationState.oldFrame
          animationState.oldFrame = animationState.nextFrame
          animationState = calculateNewAnimationState(animationState)
          let frame = interpolateFrames(animationState.oldFrame, animationState.nextFrame, (timeSinceFrame - nextFrameThreshold) / nextFrameThreshold, interpolationStart)
          drawPixels(ctx, frame)
          drawTriangles(ctx, 160, 60, frame)
      } else {
          let interpolationWeight = timeSinceFrame / nextFrameThreshold
          let frame = interpolateFrames(animationState.oldFrame, animationState.nextFrame, timeSinceFrame / nextFrameThreshold, interpolationStart)
          drawPixels(ctx, frame)
          drawTriangles(ctx, 160, 60, frame)
      }
      window.requestAnimationFrame(update)
  }
  return update
}
      const baseFrame = []
      updatePixels([2], [255, 0, 255], baseFrame)
      updatePixels([0, 1, 3, 4, 5, 6, 7], [0, 0, 0], baseFrame)
      // Sets how many miliseconds to wait between calculating new frames, in interpolates for values before this range
      const nextFrameThreshold = 350
      const calculateNewAnimationState = (animationState) => {
          const nextFrame = []
          const prevFrame = animationState.oldFrame
          const updateNextFrame = (ids, rgb) => updatePixels(ids, rgb, nextFrame)
          let reverse = animationState.extraFields.reverse
          if(!reverse) {
              updateNextFrame([2], prevFrame[6])
              updateNextFrame([1], [prevFrame[2][0], 0, 0])
              updateNextFrame([3], [0, 0, prevFrame[2][2]])
              updateNextFrame([0], prevFrame[1])
              updateNextFrame([4], prevFrame[3])
              updateNextFrame([5], prevFrame[4])
              updateNextFrame([7], prevFrame[0])
              updateNextFrame([6], [prevFrame[7][0], 0, prevFrame[5][2]])
              if (nextFrame[6][0] !== 0) {
                  reverse = true
              }
          } else {
              updateNextFrame([6], prevFrame[2])
              updateNextFrame([5], [prevFrame[6][0], 0, 0])
              updateNextFrame([7], [0, 0, prevFrame[6][2]])
              updateNextFrame([1], prevFrame[0])
              updateNextFrame([3], prevFrame[4])
              updateNextFrame([4], prevFrame[5])
              updateNextFrame([0], prevFrame[7])
              updateNextFrame([2], [prevFrame[1][2], 0, prevFrame[3][0]])
              if (nextFrame[2][0] !== 0) {
                  reverse = false
              }
          }

          return {...animationState, nextFrame, extraFields: {...animationState.extraFields, reverse}}
      }
      const interpolationStart = 0.1
      let update = initEngine(baseFrame, nextFrameThreshold, interpolationStart, calculateNewAnimationState)

      window.requestAnimationFrame(update)
    </script>
</html>
